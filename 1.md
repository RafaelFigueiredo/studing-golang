---


---

<h1 id="blockchain-com-golang">Blockchain com Golang</h1>
<p>Por conta de um trabalho freelancer que peguei recentemente me deparei com o seguinte problema:</p>
<blockquote>
<p>“Cada transação deve ser registrada no banco de dados de forma permanente e tenho que garantir que após a inserção esses registros não foram alterados”</p>
</blockquote>
<p>O banco de dados utilizado no projeto é o PostgreSQL, então talvez uma solução pudesse ser simplesmente restringir os privilégios do usuário no banco de dados para “apenas leitura” mas nada impediria que um usuário com privilégios alterasse um dos registros, mas vamos com calma na teoria da conspiração e começar do começo.</p>
<p><em><strong>NOTA: Neste primeiro artigo ainda não vamos utilizar o banco de dados</strong></em></p>
<h2 id="conceitos-preliminares">Conceitos Preliminares</h2>
<h3 id="o-que-é-hash-e-conhecendo-sha1">O que é hash e conhecendo SHA1?</h3>
<p>Um hash é uma string gerada através de um algoritmo de criptografia em uma unica direção, como por exemplo MD5 ou SHA1 e representa de <strong>forma única</strong> seu conteúdo original, por exemplo</p>
<pre><code>SHA1("Rafael") = 3e05c90f8530b1ba72519824415d05e08cf5718b
</code></pre>
<p>Sempre que eu codigicar a palavra “Rafael” ela vai gerar “3e05c90f8530b1ba72519824415d05e08cf5718b”, porém não é possivel através do hash descobrir que a palavra original erá “Rafael”, por isso dizemos que essa é uma <strong>criptografia unidirecional</strong>.<br>
MD5 não é recomendado pois tem brechas de segurança que permitem que o mesmo conteúdo gera o mesmo hash, o que seria extremamente preocupante caso a informaão de uma transação como <code>{To: 'Antonio da Feira', Amount: 3}</code> pudesse ter o mesmo identificador que <code>{To: 'Fundacao L...', Amount: 30000000}</code>, <strong>não use MD5</strong>.</p>
<h3 id="o-que-é-blockchain">O que é Blockchain?</h3>
<p>Uma blockchain ou “cadeia de blocos” é um estrutura lógica em que cada registro,“bloco”, além do seu conteúdo possui um hash gerado a partir das informações contidas nele, e também o hash do registro anterior</p>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Estrutura de um bloco</span>
<span class="token keyword">type</span> Block <span class="token keyword">struct</span><span class="token punctuation">{</span>
  Id        <span class="token builtin">int</span>
  Data      <span class="token builtin">string</span>
  <span class="token operator">...</span>
  LastHash  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
  Hash      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>`
</code></pre>
<ul>
<li><strong>Data</strong>: A informação que queremos armazenar, pode ser um conjunto complexo de dados no formato JSON como <code>"{Amount: 1.034, Currency: 'BRL', etc...}"</code></li>
<li><strong>Hash</strong>: Gerado utilizando SHA1 e representa todas as informações do bloco <code>SHA1(Id + Data + LastHash + ...)</code></li>
<li><strong>LastHash</strong>: Se este é o bloco N, então LastHash indica o hash do bloco anterior, ou sejna, N-1</li>
</ul>
<p>Essa referência a informação do bloco anterior que é a grande sacada da blockchain, assim mesmo que alterássemos a informação de um bloco e atualizássemos seu hash para parecer que nada aconteceu, o bloco seguinte utiliza esse dado para gerar seu próprio hash e seria necessário alterar o hash de todos os outros blocos da cadeia, o que devido a prova de esforço é computacionalmente impossível.</p>
<h3 id="o-que-é-prova-de-esforço-e-mineração">O que é prova de esforço e mineração?</h3>
<p>Simplesmente gerar um hash leva alguns milissegundos, então precisamos estabelecer um critério a ser atingido para que o hash seja aceito, e fazemos isso estabelecendo por exemplo que ele deva começar com uma certa quantidade de zeros, <code>00e5c90f8530b1ba72519824415d05e08cf5718b</code>.<br>
O processo de <strong>mineirar</strong> consiste em iteradamente modificar o conteúdo do bloco até que ele gere um hash que atende ao requisito da prova de esforço. Para que o hash mude a cada iteração introduzimos a variável <code>ntimes</code>(n-vezes), que é incrementada a cada iteração.<br>
No nosso código controlamos essa quantidade de zeros para o hash ser aceito com a variável <code>dificult</code>, com o valor padrão 2, assim temos um tempo de processamento de alguns segundos por bloco, se utilizássemos uma dificuldade de 3 zeros levaria em torno de 10 minutos por bloco o que seria inviável por conta da frequência com que queremos gravar um registro.</p>
<h2 id="lets-code">Let’s Code</h2>
<p>Acho que um bom ponto de partida é como queremos utilizar a biblioteca.</p>
<pre class=" language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
  <span class="token comment">// Init</span>
  <span class="token keyword">var</span> blockChain Blockchain
  blockChain<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  		<span class="token comment">// Inicia com dificuldade 2 </span>
  
  <span class="token comment">// Cria e adiciona um bloco</span>
  b <span class="token operator">:=</span> Block<span class="token punctuation">{</span>Data<span class="token punctuation">:</span> <span class="token string">"{Action:'BUY'}"</span><span class="token punctuation">}</span>
  blockChain<span class="token punctuation">.</span><span class="token function">AddBlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
  <span class="token comment">//Imprime o hash de um bloco</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Block hash: "</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>Hash<span class="token punctuation">)</span>

  <span class="token comment">//Imprime o estatus da blockchain</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Chain integrity ok?"</span><span class="token punctuation">,</span> blockChain<span class="token punctuation">.</span><span class="token function">IsIntegre</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// Imprime o ultimo bloco adicionado</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"LastBlock?"</span><span class="token punctuation">,</span> blockChain<span class="token punctuation">.</span><span class="token function">LastBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>No topo do nosso código</strong><br>
Para esse projeto vamos precisar da biblioteca <code>crypto/sha1</code> para gerar os hashs, essa biblioteca retorna o hash como um array de bytes <code>[]byte</code>e por isso também vamos precisar da biblioteca <code>bytes</code> para podermos fazer comparações e gerar sequencias de bytes. A biblioteca <code>time</code> é utilizada para registrar a data-hora da criação de cada bloco.</p>
<pre class=" language-go"><code class="prism  language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
  <span class="token string">"fmt"</span>
  <span class="token string">"bytes"</span>
  <span class="token string">"time"</span>
  <span class="token string">"crypto/sha1"</span>
  <span class="token punctuation">)</span>
</code></pre>
<p><strong>Banco de Dados</strong><br>
Por enquanto não estamos utilizando o banco de dados, mas podemos representalo por um mapa em que a chave é o id e o valor é cada bloco.</p>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Esse mapa representa nosso banco de dados</span>
<span class="token keyword">var</span> dbChain <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token operator">*</span>Block<span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<p>Referenciando cada bloco através de um ponteiro, <code>*Block</code>, podemos acessar os dados de um bloco logo apos adiciona-lo a cadeia sem a necessidade de pesquisarmos ela pelo id, <code>dbChain[Id]</code><br>
<strong>Estrutura de um bloco</strong></p>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Estrutura de um bloco</span>
<span class="token keyword">type</span> Block <span class="token keyword">struct</span><span class="token punctuation">{</span>
  Id        <span class="token builtin">int</span>
  Data      <span class="token builtin">string</span>
  LastHash  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
  Datetime  time<span class="token punctuation">.</span>Time
  NTimes     <span class="token builtin">uint64</span>
  Hash      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
<span class="token punctuation">}</span>`
</code></pre>
<ul>
<li><strong>Id</strong>: Autoincrementado a cada bloco</li>
<li><strong>Data</strong>: Conteúdo do bloco</li>
<li><strong>LastHash</strong>: Hash do bloco anterior</li>
<li><strong>Datetime</strong>: Data-hora de inserçao do bloco</li>
<li><strong>NTimes</strong>: Variável utilizada</li>
<li><strong>Hash</strong>: Hash do bloco</li>
</ul>
<p><strong>Gera o hash para o conteúdo do bloco</strong><br>
A função abaixo retorna um rash do conteúdo do bloco, observe que ela considera apenas o estado atual das variáveis.</p>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Gera o hash para o conteúdo do bloco</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>bc Block<span class="token punctuation">)</span> <span class="token function">DoHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span>
  bv <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>bc<span class="token punctuation">.</span>Id<span class="token punctuation">)</span> <span class="token operator">+</span> bc<span class="token punctuation">.</span>Data <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>bc<span class="token punctuation">.</span>LastHash<span class="token punctuation">)</span> <span class="token operator">+</span> bc<span class="token punctuation">.</span>Datetime<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">string</span><span class="token punctuation">(</span>bc<span class="token punctuation">.</span>NTimes<span class="token punctuation">)</span><span class="token punctuation">)</span>
  hasher <span class="token operator">:=</span> sha1<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  hasher<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>bv<span class="token punctuation">)</span>
  sha_bytes <span class="token operator">:=</span> hasher<span class="token punctuation">.</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> sha_bytes
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Blockchain</strong><br>
Esta estrutura ira conter os métodos para:</p>
<ul>
<li>Adicionar um bloco novo <code>Add(b *Block)</code>;</li>
<li>Validar se os dados estão íntegros <code>IsIntegre()</code>;</li>
<li><code>Mine(b *Block)</code> que trabalha em loop até que o hash gerado atenda aos requisitos da prova de esforço.</li>
</ul>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Representa a blockchain</span>
<span class="token keyword">type</span> Blockchain <span class="token keyword">struct</span><span class="token punctuation">{</span>
  dificult <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre>
<p>A variável <code>dificult</code> vai determinar o requisito da prova de esforço, ou seja, quantos caracteres <code>0</code>(zero) vamos querer no início do nosso hash.</p>
<p><strong>Bloco Genese e Init()</strong><br>
A verificação de integridade compara o conteúdo de um bloco com o bloco anterior, então o bloco zero precisa ser inserido manualmente e faremos isso dentro da função <code>Init()</code></p>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Inicializa adicionando o bloco de genese</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  genesisBlock <span class="token operator">:=</span> Block<span class="token punctuation">{</span>Id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> Data<span class="token punctuation">:</span> <span class="token string">"{}"</span><span class="token punctuation">,</span> LastHash<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Datetime<span class="token punctuation">:</span> time<span class="token punctuation">.</span><span class="token function">Date</span><span class="token punctuation">(</span><span class="token number">2018</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>May<span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>UTC<span class="token punctuation">)</span><span class="token punctuation">,</span> NTimes<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span>
  bc<span class="token punctuation">.</span><span class="token function">Mine</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>genesisBlock<span class="token punctuation">)</span>
  dbChain<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>genesisBlock
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Adiciona bloco</strong><br>
Monta o bloco com base nas informações do bloco anterior, incrementando o Id e recuperando o hash anterior</p>
<pre class=" language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">AddBlock</span><span class="token punctuation">(</span>b <span class="token operator">*</span>Block<span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>
  lastBlock <span class="token operator">:=</span> bc<span class="token punctuation">.</span><span class="token function">LastBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  b<span class="token punctuation">.</span>Id <span class="token operator">=</span> lastBlock<span class="token punctuation">.</span>Id <span class="token operator">+</span> <span class="token number">1</span>
  b<span class="token punctuation">.</span>LastHash <span class="token operator">=</span> lastBlock<span class="token punctuation">.</span>Hash
  b<span class="token punctuation">.</span>Datetime <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  b<span class="token punctuation">.</span>NTimes<span class="token operator">=</span><span class="token number">0</span>

  bc<span class="token punctuation">.</span><span class="token function">Mine</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>

  i <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>dbChain<span class="token punctuation">)</span>
  dbChain<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> b
  <span class="token keyword">return</span> i
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Last Block</strong><br>
Retorna o ultimo bloco da cadeia, essa função é util pois precisamos incrementar o  <code>Id</code> e também do hash do ultimo bloco.</p>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Retorna o útlimo bloco da cadeia</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">LastBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Block<span class="token punctuation">{</span>
  <span class="token keyword">return</span> dbChain<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>dbChain<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Mineirar</strong></p>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Gera um hash baseado na dificuldade da cadeia</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">Mine</span><span class="token punctuation">(</span>block <span class="token operator">*</span>Block<span class="token punctuation">)</span><span class="token punctuation">{</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Mining block..."</span><span class="token punctuation">)</span>
  <span class="token keyword">var</span> hash <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>bytes<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span> hash<span class="token punctuation">,</span> bytes<span class="token punctuation">.</span><span class="token function">Repeat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bc<span class="token punctuation">.</span>dificult<span class="token punctuation">)</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span>
    block<span class="token punctuation">.</span>NTimes <span class="token operator">=</span> block<span class="token punctuation">.</span>NTimes <span class="token operator">+</span> <span class="token number">1</span>
    hash <span class="token operator">=</span> block<span class="token punctuation">.</span><span class="token function">DoHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  block<span class="token punctuation">.</span>Hash<span class="token operator">=</span>hash
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Checa a integridade da cadeia</strong></p>
<pre class=" language-go"><code class="prism  language-go"><span class="token comment">// Checa a integridade da cadeia</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>bc <span class="token operator">*</span>Blockchain<span class="token punctuation">)</span> <span class="token function">IsIntegre</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">{</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Checking integrity..."</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>dbChain<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    <span class="token comment">//verifica se o conteudo do bloco foi alterado</span>
    <span class="token keyword">if</span> bytes<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>dbChain<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Hash<span class="token punctuation">,</span> dbChain<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">DoHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token number">0</span> <span class="token punctuation">{</span>
      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Bloco modificado após a criação, corrompido"</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//verifica se o bloco referencia o bloco anterior</span>
    <span class="token keyword">if</span> i<span class="token operator">&gt;</span><span class="token number">0</span> <span class="token punctuation">{</span>  <span class="token comment">//ignora a verificação do bloco anterior para o bloco genese</span>
      <span class="token keyword">if</span> bytes<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>dbChain<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>LastHash<span class="token punctuation">,</span> dbChain<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Hash<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Bloco não referencia o bloco anterior, corrompido"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre>

